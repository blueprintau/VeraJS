#!/usr/bin/env node
/**
 * Build script to generate TypeScript definitions from JSDoc comments
 * Run with: node scripts/generate-types.js
 */

import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

let interfaces = [
    {
        name: 'VeraRef',
        code: `interface VeraRef<T = any> {
    _id: string;
    _value: T;
    _observers: Array<(value: T) => void>;
    _ref: true;
    _isElement: boolean;
    _element: any;
    getValue(): T;
    setValue(value: T): void;
    addObserver(callback: (value: T) => void): void;
  }`
    },
    {
        name: 'VeraStore',
        code: `interface VeraStore<T = Record<string, any>> {
    _id: string;
    _name: string;
    _initialState: T;
    _state: T;
    _observers: Array<(state: T) => void>;
    _ref: true;
    _store: true;
    getState(): T;
    getState<K extends keyof T>(key: K): T[K];
    setState(updates: Partial<T> | ((prevState: T) => Partial<T>)): void;
    reset(newState?: T): void;
    addObserver(callback: (state: T) => void): void;
  }`
    }
];

console.log('ðŸ”¨ Generating TypeScript definitions from JSDoc...');

// Configuration
const config = {
    sourceDir: './src',
    outputDir: './dist',
    outputFile: 'vera.d.ts',
    tempDir: './temp-types'
};

try {
    // Step 1: Create temp directory
    if (!fs.existsSync(config.tempDir)) {
        fs.mkdirSync(config.tempDir, { recursive: true });
    }

    // Step 2: Use TypeScript compiler to generate .d.ts from JSDoc
    console.log('ðŸ“ Extracting types from JSDoc comments...');

    // Create a temporary tsconfig for reliable glob handling
    const tempTsConfig = {
        compilerOptions: {
            declaration: true,
            allowJs: true,
            emitDeclarationOnly: true,
            outDir: config.tempDir,
            target: "ES2020",
            module: "ESNext",
            moduleResolution: "node",
            skipLibCheck: true
        },
        include: [
            "src/**/*.js"
        ]
    };

    const tempConfigPath = './tsconfig.temp.json';
    fs.writeFileSync(tempConfigPath, JSON.stringify(tempTsConfig, null, 2));

    try {
        execSync(`npx tsc --project ${tempConfigPath}`, { stdio: 'pipe' });
    } finally {
        // Clean up temp config
        if (fs.existsSync(tempConfigPath)) {
            fs.unlinkSync(tempConfigPath);
        }
    }

    // Step 3: Read generated .d.ts files and combine them
    console.log('ðŸ”„ Processing generated definitions...');

    const generatedTypes = [];
    const processDirectory = (dir) => {
        const files = fs.readdirSync(dir);

        files.forEach(file => {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);

            if (stat.isDirectory()) {
                processDirectory(filePath);
            } else if (file.endsWith('.d.ts')) {
                const content = fs.readFileSync(filePath, 'utf8');
                generatedTypes.push({
                    file: filePath,
                    content: content
                });
            }
        });
    };

    processDirectory(config.tempDir);

    // Step 4: Generate the final .d.ts file
    console.log('âš¡ Creating final type definitions...');

    const finalDts = generateFinalDts(generatedTypes);

    // Step 5: Write to output
    if (!fs.existsSync(config.outputDir)) {
        fs.mkdirSync(config.outputDir, { recursive: true });
    }

    const outputPath = path.join(config.outputDir, config.outputFile);
    fs.writeFileSync(outputPath, finalDts);

    // Step 6: Cleanup
    fs.rmSync(config.tempDir, { recursive: true, force: true });

    console.log(`âœ… Generated ${outputPath}`);
    console.log(`ðŸ“¦ File size: ${(fs.statSync(outputPath).size / 1024).toFixed(2)} KB`);

} catch (error) {
    console.error('âŒ Error generating types:', error.message);

    // Cleanup on error
    if (fs.existsSync(config.tempDir)) {
        fs.rmSync(config.tempDir, { recursive: true, force: true });
    }

    process.exit(1);
}

/**
 * Generate the final .d.ts content from extracted types
 * @param {Array} typeFiles - Array of type file objects
 * @returns {string} Final .d.ts content
 */
function generateFinalDts(typeFiles) {
    const header = `// Auto-generated TypeScript definitions for VeraJS
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually - it will be overwritten on next build

declare global {
`;

    const footer = `}

export {};
`;

    let interfaceDefinitions = '';
    let classDefinitions = '';
    let functionDefinitions = '';

    const definedInterfaces = new Set();
    const definedClasses = new Set();
    const definedFunctions = new Set();

    typeFiles.forEach(({ content }) => {
        // Extract typedefs
        const typedefMatches = content.match(/\/\*\*[\s\S]*?@typedef[\s\S]*?\*\//g);
        if (typedefMatches) {
            typedefMatches.forEach(typedef => {
                const interfaceCode = convertTypedefToInterface(typedef);
                const interfaceName = extractInterfaceName(interfaceCode);
                if (interfaceCode && interfaceName && !definedInterfaces.has(interfaceName)) {
                    interfaceDefinitions += '  ' + interfaceCode.split('\n').join('\n  ') + '\n\n';
                    definedInterfaces.add(interfaceName);
                }
            });
        }

        // Extract classes - REMOVE "declare" keyword
        const classMatches = content.match(/declare class \w+\s*{[\s\S]*?^}/gm);
        if (classMatches) {
            classMatches.forEach(classDecl => {
                const className = classDecl.match(/declare class (\w+)/)?.[1];
                if (className && !definedClasses.has(className)) {
                    // Remove "declare" keyword since we're in an ambient context
                    const cleanedDecl = classDecl.replace(/^declare /, '');
                    classDefinitions += '  ' + cleanedDecl.split('\n').join('\n  ') + '\n\n';
                    definedClasses.add(className);
                }
            });
        }


        const lines = content.split('\n');
        let currentFunction = '';
        let braceCount = 0;
        let inFunction = false;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];

            if (line.match(/^export function \w+/)) {
                inFunction = true;
                currentFunction = line.replace(/^export\s+/, '');
                braceCount = (line.match(/{/g) || []).length - (line.match(/}/g) || []).length;

                if (line.includes(';') && braceCount === 0) {
                    // Single line function
                    const functionName = currentFunction.match(/function (\w+)/)?.[1];
                    if (functionName && !definedFunctions.has(functionName)) {
                        functionDefinitions += '  ' + currentFunction + '\n';
                        definedFunctions.add(functionName);
                    }
                    inFunction = false;
                    currentFunction = '';
                }
            } else if (inFunction) {
                currentFunction += '\n' + line;
                braceCount += (line.match(/{/g) || []).length;
                braceCount -= (line.match(/}/g) || []).length;

                if (line.includes(';') && braceCount === 0) {
                    // Multi-line function complete
                    const functionName = currentFunction.match(/function (\w+)/)?.[1];
                    if (functionName && !definedFunctions.has(functionName)) {
                        // Format it nicely with proper indentation
                        const formattedFunc = currentFunction
                            .split('\n')
                            .map(l => l.trim())
                            .join('\n  ');
                        functionDefinitions += '  ' + formattedFunc + '\n';
                        definedFunctions.add(functionName);
                    }
                    inFunction = false;
                    currentFunction = '';
                }
            }
        }

        // Add standard interfaces if not already defined
        interfaces.forEach(({ name, code }) => {
            if (!definedInterfaces.has(name)) {
                interfaceDefinitions += '  ' + code + '\n\n';
                definedInterfaces.add(name);
            }
        });
    });

    return header + interfaceDefinitions + classDefinitions + functionDefinitions + footer;
}
/**
 * Extract interface name from interface code
 * @param {string} interfaceCode - TypeScript interface code
 * @returns {string|null} Interface name or null
 */
function extractInterfaceName(interfaceCode) {
    const match = interfaceCode.match(/interface\s+(\w+)/);
    return match ? match[1] : null;
}

/**
 * Convert JSDoc @typedef to TypeScript interface
 * @param {string} typedef - JSDoc typedef comment
 * @returns {string} TypeScript interface
 */
function convertTypedefToInterface(typedef) {
    const nameMatch = typedef.match(/@typedef\s+{[^}]*}\s+(\w+)/);
    if (!nameMatch) return '';

    const interfaceName = nameMatch[1];

    // Check for @template (generics)
    const templateMatch = typedef.match(/@template\s+(\w+)/);
    const genericParam = templateMatch ? `<${templateMatch[1]} = any>` : '';

    const properties = [];

    const propMatches = typedef.match(/@property\s+{[^}]*}\s+\[?(\w+)]?\s*-?\s*(.*)/g);
    if (propMatches) {
        propMatches.forEach(prop => {
            const match = prop.match(/@property\s+{([^}]*)}\s+\[?(\w+)]?\s*-?\s*(.*)/);
            if (match) {
                const [, type, name, description] = match;
                const optional = prop.includes(`[${name}]`) ? '?' : '';
                const tsType = convertJSDocTypeToTS(type);
                properties.push(`  ${name}${optional}: ${tsType}; // ${description}`);
            }
        });
    }

    return `interface ${interfaceName}${genericParam} {\n${properties.join('\n')}\n}`;
}

/**
 * Convert JSDoc type to TypeScript type
 * @param {string} jsDocType - JSDoc type string
 * @returns {string} TypeScript type
 */
function convertJSDocTypeToTS(jsDocType) {
    const typeMap = {
        'Object': 'object',
        'Array': 'any[]',
        'Function': 'Function',
        '*': 'any',
        'true': 'true',
        'false': 'false'
    };

    // Handle function types: function(T): void -> (arg: T) => void
    if (jsDocType.startsWith('function(')) {
        const paramsMatch = jsDocType.match(/function\(([^)]*)\):\s*(.+)/);
        if (paramsMatch) {
            const params = paramsMatch[1];
            const returnType = paramsMatch[2].trim();

            if (params) {
                // Has parameters
                const paramList = params.split(',').map((p, i) => `arg${i}: ${p.trim()}`).join(', ');
                return `(${paramList}) => ${returnType}`;
            } else {
                // No parameters
                return `() => ${returnType}`;
            }
        }
    }

    // Handle Array<T>
    if (jsDocType.startsWith('Array<')) {
        const innerType = jsDocType.match(/Array<(.+)>/)?.[1];
        if (innerType) {
            return `Array<${convertJSDocTypeToTS(innerType)}>`;
        }
    }

    // Handle Partial<T>
    if (jsDocType.startsWith('Partial<')) {
        return jsDocType; // Already valid TypeScript
    }

    // Handle union types: T|U
    if (jsDocType.includes('|')) {
        return jsDocType.split('|').map(t => convertJSDocTypeToTS(t.trim())).join(' | ');
    }

    return typeMap[jsDocType] || jsDocType;
}