#!/usr/bin/env node
/**
 * Build script to generate TypeScript definitions from JSDoc comments
 * Run with: node scripts/generate-types.js
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('üî® Generating TypeScript definitions from JSDoc...');

// Configuration
const config = {
    sourceDir: './src',
    outputDir: './dist',
    outputFile: 'vera.d.ts',
    tempDir: './temp-types'
};

try {
    // Step 1: Create temp directory
    if (!fs.existsSync(config.tempDir)) {
        fs.mkdirSync(config.tempDir, { recursive: true });
    }

    // Step 2: Use TypeScript compiler to generate .d.ts from JSDoc
    console.log('üìù Extracting types from JSDoc comments...');

    const tscCommand = [
        'npx tsc',
        `${config.sourceDir}/**/*.js`,
        '--declaration',
        '--allowJs',
        '--emitDeclarationOnly',
        `--outDir ${config.tempDir}`,
        '--target ES2020',
        '--module ESNext',
        '--moduleResolution node',
        '--skipLibCheck'
    ].join(' ');

    execSync(tscCommand, { stdio: 'pipe' });

    // Step 3: Read generated .d.ts files and combine them
    console.log('üîÑ Processing generated definitions...');

    const generatedTypes = [];
    const processDirectory = (dir) => {
        const files = fs.readdirSync(dir);

        files.forEach(file => {
            const filePath = path.join(dir, file);
            const stat = fs.statSync(filePath);

            if (stat.isDirectory()) {
                processDirectory(filePath);
            } else if (file.endsWith('.d.ts')) {
                const content = fs.readFileSync(filePath, 'utf8');
                generatedTypes.push({
                    file: filePath,
                    content: content
                });
            }
        });
    };

    processDirectory(config.tempDir);

    // Step 4: Generate the final .d.ts file
    console.log('‚ö° Creating final type definitions...');

    const finalDts = generateFinalDts(generatedTypes);

    // Step 5: Write to output
    if (!fs.existsSync(config.outputDir)) {
        fs.mkdirSync(config.outputDir, { recursive: true });
    }

    const outputPath = path.join(config.outputDir, config.outputFile);
    fs.writeFileSync(outputPath, finalDts);

    // Step 6: Cleanup
    fs.rmSync(config.tempDir, { recursive: true, force: true });

    console.log(`‚úÖ Generated ${outputPath}`);
    console.log(`üì¶ File size: ${(fs.statSync(outputPath).size / 1024).toFixed(2)} KB`);

} catch (error) {
    console.error('‚ùå Error generating types:', error.message);

    // Cleanup on error
    if (fs.existsSync(config.tempDir)) {
        fs.rmSync(config.tempDir, { recursive: true, force: true });
    }

    process.exit(1);
}

/**
 * Generate the final .d.ts content from extracted types
 * @param {Array} typeFiles - Array of type file objects
 * @returns {string} Final .d.ts content
 */
function generateFinalDts(typeFiles) {
    const header = `// Auto-generated TypeScript definitions for VeraJS
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually - it will be overwritten on next build

`;

    const globalDeclarations = `declare global {
  // VeraJS Framework API
  const VeraJS: {
    mount(id: string): VeraJSInstance;
    router(): VeraRouter;
    registerComponentClass(key: string, componentClass: typeof Component): void;
    addComponent(component: Component): void;
    ABORT_MOUNT: symbol;
    
    _componentClasses: Map<string, typeof Component>;
    _instance: VeraJSInstance;
    
    useRef: typeof useRef;
    getRef: typeof getRef;
    useStore: typeof useStore;
    getStore: typeof getStore;
    useEffect: typeof useEffect;
    isRef: typeof isRef;
    rule: typeof rule;
    useCookie: typeof useCookie;
    setCookie: typeof setCookie;
    getCookie: typeof getCookie;
    removeCookie: typeof removeCookie;
    unwrapElement: typeof unwrapElement;
    unixToDate: typeof unixToDate;
    Component: typeof Component;
    
    get instance(): VeraJSInstance;
    getComponentClasses(): Map<string, typeof Component>;
  };

  // Global utility functions
  const useRef: <T = any>(value?: T, id?: string) => VeraRef<T>;
  const getRef: (id: string) => VeraRef | null;
  const useStore: <T = Record<string, any>>(name: string, initialState?: T) => VeraStore<T>;
  const getStore: <T = Record<string, any>>(name: string) => VeraStore<T> | null;
  const useEffect: (callback: () => void, refs?: VeraRef[]) => void;
  const isRef: (object: any) => object is VeraRef;
  const rule: () => Rule;
  const useCookie: (name: string, initialValue?: string | null, expires?: number, path?: string) => VeraRef<string>;
  const setCookie: (name: string, value: string, expires?: number | Date | null, path?: string) => void;
  const getCookie: (name: string, defaultValue?: string | null) => string | null;
  const removeCookie: (name: string, options?: { path?: string }) => void;
  const unwrapElement: (element: HTMLElement) => void;
  const unixToDate: (unixTimestamp: number) => Date;

  // Component base class
  class Component {
    _element: HTMLElement;
    _id: string;
    _parent: Component | null;

    getComputedStyle(style: string, int?: boolean): string | number;
    querySelector(selector: string, all?: false): Element | null;
    querySelector(selector: string, all: true): NodeListOf<Element>;
    _evaluateChildComponents(): void;
    _checkElementAndChildren(element: HTMLElement): void;
    getTemplate(): string;
    init(props?: ComponentProps): void;
    beforeMount?(): void | symbol;
    getElement(): HTMLElement;
  }
}

`;

    // Track which interfaces we've already defined to avoid duplicates
    const definedInterfaces = new Set();

    // Extract and clean up the interface definitions from generated files
    let interfaceDefinitions = '';

    typeFiles.forEach(({ content }) => {
        // Extract typedef comments and convert to interfaces
        const typedefMatches = content.match(/\/\*\*[\s\S]*?@typedef[\s\S]*?\*\//g);
        if (typedefMatches) {
            typedefMatches.forEach(typedef => {
                const interfaceCode = convertTypedefToInterface(typedef);
                const interfaceName = extractInterfaceName(interfaceCode);

                // Only add if we haven't defined this interface yet
                if (interfaceCode && interfaceName && !definedInterfaces.has(interfaceName)) {
                    interfaceDefinitions += interfaceCode + '\n\n';
                    definedInterfaces.add(interfaceName);
                }
            });
        }
    });

    // Add standard interfaces that we always need (but only if not already defined)
    const standardInterfaces = [
        {
            name: 'ComponentProps',
            code: `interface ComponentProps {
  id?: string;
  innerHTML?: string;
  [key: string]: any;
}`
        },
        {
            name: 'VeraRef',
            code: `interface VeraRef<T = any> {
  _id: string;
  _value: T;
  _observers: Array<(value: T) => void>;
  _ref: true;
  _isElement: boolean;
  _element: any;
  
  getValue(): T;
  setValue(value: T): void;
  addObserver(callback: (value: T) => void): void;
}`
        },
        {
            name: 'VeraStore',
            code: `interface VeraStore<T = Record<string, any>> {
  _id: string;
  _name: string;
  _initialState: T;
  _state: T;
  _observers: Array<(state: T) => void>;
  _ref: true;
  _store: true;

  getState(): T;
  getState<K extends keyof T>(key: K): T[K];
  setState(updates: Partial<T> | ((prevState: T) => Partial<T>)): void;
  reset(newState?: T): void;
  addObserver(callback: (state: T) => void): void;
}`
        },
        {
            name: 'RouteMatch',
            code: `interface RouteMatch {
  component: any;
  params: Record<string, string>;
  path: string;
  route?: string;
}`
        },
        {
            name: 'VeraRouter',
            code: `declare class VeraRouter {
  _anchorComponent: Component;
  
  route(route: string, component: any, layout?: any): this;
  _setAnchorComponent(component: Component): void;
  getCurrentMatch(): RouteMatch | null;
  isCurrentRoute(routePath: string): boolean;
  navigate(path: string): void;
  start(): this;
}`
        },
        {
            name: 'Rule',
            code: `interface Rule {
  checks: Record<string, any>;
  min(value: number): Rule;
  max(value: number): Rule;
  regex(regex: RegExp): Rule;
  parse(value: string): boolean;
}`
        },
        {
            name: 'VeraJSInstance',
            code: `interface VeraJSInstance {
  _components: Map<string, Component>;
  _registeredComponents: any[];
  _observer: any[];
  _refs: VeraRef[];
  _whenReady: Array<() => void>;
  _root: Component;
  _router: VeraRouter;
  _stores: Map<string, VeraStore>;
  _setup: () => void | Promise<void>;

  _evaluateRefs(selector?: HTMLElement): void;
  _addRef(ref: VeraRef): void;
  _getRef(id: string): VeraRef | undefined;
  _addComponent(component: Component): void;
  whenReady(callback: () => void): void;
  setUp(callback: () => void | Promise<void>): this;
}`
        }
    ];

    let standardInterfaceCode = '';
    standardInterfaces.forEach(({ name, code }) => {
        if (!definedInterfaces.has(name)) {
            standardInterfaceCode += code + '\n\n';
            definedInterfaces.add(name);
        }
    });

    return header + globalDeclarations + interfaceDefinitions + standardInterfaceCode + '\nexport {};\n';
}

/**
 * Extract interface name from interface code
 * @param {string} interfaceCode - TypeScript interface code
 * @returns {string|null} Interface name or null
 */
function extractInterfaceName(interfaceCode) {
    const match = interfaceCode.match(/interface\s+(\w+)/);
    return match ? match[1] : null;
}

/**
 * Convert JSDoc @typedef to TypeScript interface
 * @param {string} typedef - JSDoc typedef comment
 * @returns {string} TypeScript interface
 */
function convertTypedefToInterface(typedef) {
    // This is a simplified converter - you can enhance it based on your needs
    const nameMatch = typedef.match(/@typedef\s+{[^}]*}\s+(\w+)/);
    if (!nameMatch) return '';

    const interfaceName = nameMatch[1];
    const properties = [];

    const propMatches = typedef.match(/@property\s+{[^}]*}\s+\[?(\w+)\]?\s*-?\s*(.*)/g);
    if (propMatches) {
        propMatches.forEach(prop => {
            const match = prop.match(/@property\s+{([^}]*)}\s+\[?(\w+)\]?\s*-?\s*(.*)/);
            if (match) {
                const [, type, name, description] = match;
                const optional = prop.includes(`[${name}]`) ? '?' : '';
                const tsType = convertJSDocTypeToTS(type);
                properties.push(`  ${name}${optional}: ${tsType}; // ${description}`);
            }
        });
    }

    return `interface ${interfaceName} {\n${properties.join('\n')}\n}`;
}

/**
 * Convert JSDoc type to TypeScript type
 * @param {string} jsDocType - JSDoc type string
 * @returns {string} TypeScript type
 */
function convertJSDocTypeToTS(jsDocType) {
    const typeMap = {
        'Object': 'object',
        'Array': 'any[]',
        'Function': 'Function',
        '*': 'any'
    };

    return typeMap[jsDocType] || jsDocType;
}